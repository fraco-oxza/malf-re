@startuml

abstract class Automaton {
    #states
    #alphabet
    #transitions
    #initialState
    #finalStates

    +Automaton(ALL_PARAMS);

    +toString();
}
note left {
    Vicho
}

class OptimizedDFA extends DFA {
    +OptimizedDFA(DFA);
}
note left of OptimizedDFA {
    Vicho
}

class DFA extends Automaton {
    -statesTable
    +DFA(NFA);
}
note left {
    Benja
}

class NFA extends Automaton {
    +NFA(Expression);
}
note left {
    Pancho
}

interface Expressions.ConvertToNFA {
    +toNFA();
}

class Expressions.Expression implements Expressions.ConvertToNFA {
    +Expression(String raw_expression)
}

class Expressions.Char extends Expressions.Expression {
    - character: char
    +toNFA()
}

class Expressions.Empty extends Expressions.Expression {
    +toNFA()
}

class Expressions.Disjunction extends Expressions.Expression {
    expression1: Expression
    expression2: Expression
}

class Expressions.Concatenation extends Expressions.Expression {
    expression1: Expression
    expression2: Expression
}

class Expressions.Kleen extends Expressions.Expression {
    expression: Expressions.Expression
}

class Expressions.Parenthesis extends Expressions.Expression {
    expression: Expressions.Expression
}




note left {
    Pancho
}

class Transition {
    -fromNode
    -character
    -toNode
}
note left {
    Vicho
}

enum Operator {
    CONCATENATION
    UNION
    KLEENE_CLOSURE
}

enum Constants {
    EPSILON
    PHI
}

class InvalidExpression extends Exception {
}
note left {
    pancho
}

class AutomatonExamples {
    {static} +nfas: List<NFA>
    {static} +dfas: List<DFA>
    {static} +expressions: List<Expression>
}
note left{
    Benja
}

@enduml